Clang-11 LTO
RISC-V self-test OK
* All benchmark results are measured in 200x2000 samples
         libriscv: function call	median 10ns  		lowest: 10ns     	highest: 27ns

            native: array append	median 0ns  		lowest: 0ns     	highest: 0ns
          libriscv: array append	median 35ns  		lowest: 34ns     	highest: 76ns
     libriscv: array app. direct	median 25ns  		lowest: 25ns     	highest: 30ns
            lua5.3: table append	median 212ns  		lowest: 209ns     	highest: 241ns

        libriscv: many arguments	median 150ns  		lowest: 142ns     	highest: 191ns
          lua5.3: many arguments	median 751ns  		lowest: 729ns     	highest: 889ns

          libriscv: integer math	median 44ns  		lowest: 43ns     	highest: 66ns
            lua5.3: integer math	median 249ns  		lowest: 247ns     	highest: 275ns

         libriscv: syscall print	median 66ns  		lowest: 64ns     	highest: 100ns
           lua5.3: syscall print	median 215ns  		lowest: 213ns     	highest: 314ns

       libriscv: complex syscall	median 779ns  		lowest: 756ns     	highest: 921ns
         lua5.3: complex syscall	median 1417ns  		lowest: 1369ns     	highest: 1485ns

         libriscv: micro threads	median 275ns  		lowest: 270ns     	highest: 313ns
              lua5.3: coroutines	median 713ns  		lowest: 688ns     	highest: 902ns

     libriscv: micro thread args	median 408ns  		lowest: 399ns     	highest: 456ns
          lua5.3: coroutine args	median 767ns  		lowest: 742ns     	highest: 1409ns

		  		libriscv: memcpy	median 5527ns  		lowest: 5405ns     	highest: 6374ns
   		libriscv: memcpy syscall	median 456ns  		lowest: 442ns     	highest: 714ns
				  lua5.3: memcpy	median 7280ns  		lowest: 6933ns     	highest: 8604ns

GCC-9 LTO
RISC-V self-test OK
* All benchmark results are measured in 200x2000 samples
         libriscv: function call	median 14ns  		lowest: 13ns     	highest: 31ns

            native: array append	median 1ns  		lowest: 1ns     	highest: 1ns
          libriscv: array append	median 47ns  		lowest: 46ns     	highest: 89ns
     libriscv: array app. direct	median 40ns  		lowest: 40ns     	highest: 68ns
            lua5.3: table append	median 207ns  		lowest: 205ns     	highest: 239ns

        libriscv: many arguments	median 213ns  		lowest: 210ns     	highest: 237ns
          lua5.3: many arguments	median 763ns  		lowest: 734ns     	highest: 956ns

          libriscv: integer math	median 62ns  		lowest: 61ns     	highest: 114ns
            lua5.3: integer math	median 250ns  		lowest: 242ns     	highest: 299ns

         libriscv: syscall print	median 85ns  		lowest: 84ns     	highest: 109ns
           lua5.3: syscall print	median 221ns  		lowest: 218ns     	highest: 255ns

       libriscv: complex syscall	median 1146ns  		lowest: 1111ns     	highest: 1637ns
         lua5.3: complex syscall	median 1505ns  		lowest: 1464ns     	highest: 1716ns

         libriscv: micro threads	median 407ns  		lowest: 395ns     	highest: 538ns
              lua5.3: coroutines	median 700ns  		lowest: 663ns     	highest: 783ns

	 libriscv: micro thread args	median 645ns  		lowest: 643ns     	highest: 677ns
          lua5.3: coroutine args	median 754ns  		lowest: 725ns     	highest: 881ns


The first benchmark, the function call, is the overhead of a single empty
function call into the RISC-V virtual machine.
The array append direct benchmark uses a function pointer address to call with,
instead of a string which has to be looked up.
The many arguments benchmark passes strings, structs and in total 8 arguments
to a function on both Lua and RISC-V.
The complex syscall benchmark executes a function in each VM that calls back
into the host 10 times using a complex system call with many arguments.
The micro threads benchmark creates a simple thread/coroutine and then yields
back and forth twice before completing the thread/coroutine. The RISC-V
implementation is 2.6x faster, and has equal features.
